<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<title>Brus Gotta Poo! â€” SVG Sprite</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  :root {
    --sky1:#cfe9ff; --sky2:#f7efe3; --ground:#d2c3a4; --grass:#9dbc6f; --track:#b6a684;
    --poo:#7b4a21; --pooEdge:#5e3a18;
    --card:#263238ee; --text:#fff; --accent:#ffd54f;
  }
  *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
  html,body{height:100%;margin:0;background:var(--sky2);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{position:fixed;inset:0;display:grid;grid-template-rows:1fr auto}
  canvas{width:100%;height:100%;display:block;touch-action:manipulation;background:linear-gradient(var(--sky1),var(--sky2))}
  .hud{display:flex;gap:10px;align-items:center;justify-content:center;padding:8px env(safe-area-inset-right) calc(8px + env(safe-area-inset-bottom)) env(safe-area-inset-left);background:linear-gradient(180deg,#0000,#0001)}
  .btn{border:0;border-radius:12px;padding:10px 14px;background:var(--accent);font-weight:800;color:#3a300e}
  .btn:active{transform:translateY(1px) scale(.99)}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
  .card{background:var(--card);color:var(--text);padding:22px 28px;border-radius:18px;box-shadow:0 14px 40px #0006;text-align:center;max-width:min(560px,86vw)}
  .title{font-size:28px;font-weight:900;margin:0 0 6px 0}
  .subtitle{font-size:18px;opacity:.95;margin:0 0 12px 0}
  .hidden{display:none!important}
  .scoreHud{position:fixed;left:12px;top:8px;background:rgba(0,0,0,.25);color:#fff;padding:10px 12px;border-radius:12px;font-weight:700;z-index:20}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="900" height="420" aria-label="Brus Gotta Poo! Endless Runner"></canvas>

  <div id="intro" class="overlay">
    <div class="card">
      <div class="title">Brus Gotta Poo!</div>
      <div class="subtitle">Tap to Begin</div>
      <button id="startBtn" class="btn">Start</button>
    </div>
  </div>

  <div id="gameOver" class="overlay hidden">
    <div class="card">
      <div class="title">Game Over ðŸ’©</div>
      <div id="finalScore" class="subtitle"></div>
      <button id="restartBtn" class="btn">Restart</button>
    </div>
  </div>

  <div id="scoreHud" class="scoreHud">Score: 0 â€¢ Best: 0</div>
  <div class="hud">
    <button id="jumpBtn" class="btn">Jump (Tap/Space)</button>
    <span class="subtitle" style="color:#000;opacity:.75">Quick taps = small hops, hold for higher jumps.</span>
  </div>
</div>

<script>
(()=>{
  // ---- Canvas & sizing ----
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
  let groundY = canvas.height * 0.80;

  function resize(){
    dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    canvas.width  = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    groundY = canvas.height * 0.80;
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ---- DOM ----
  const intro = document.getElementById('intro');
  const over = document.getElementById('gameOver');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const jumpBtn = document.getElementById('jumpBtn');
  const scoreHud = document.getElementById('scoreHud');
  function hide(el){ el.classList.add('hidden'); }
  function show(el){ el.classList.remove('hidden'); }

  // ---- State ----
  let state='intro', t=0, score=0, best=parseInt(localStorage.getItem('bru_best')||'0',10);
  const G = 3000, HOLD_MAX = 0.18;
  let jumpHold=false, holdTime=0;
  let speed = 500;
  let poops=[];

  // Runner (position & sprite)
  const dog = { x: 0, y: 0, w: 140, h: 88, vy: 0, onGround: true, legT:0, frame:0 };
  const DOG_X = ()=> canvas.width*0.2;

  // Spawn scheduling (aggressive ramp like v3.3)
  let minGap=1.4, maxGap=2.0, spawnTimer=0, nextGap=rand(minGap,maxGap);

  // ---- Helpers ----
  function rand(a,b){ return a + Math.random()*(b-a); }
  function aabb(dx,dy,dw,dh,px,pyTop,pw,phBottom){ return dx < px + pw && dx + dw > px && dy < pyTop + phBottom && dy + dh > pyTop; }

  // ---- Inline SVG sprite frames (full-color golden retriever style) ----
  // We create three frames: runA, runB, jump. Each is an SVG string turned into a data URL.
  function makeDataURL(svg){ return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg); }
  const commonDefs = `
    <defs>
      <linearGradient id="coat" x1="0" y1="0" x2="0" y2="1">
        <stop offset="0%" stop-color="#f0c171"/>
        <stop offset="100%" stop-color="#d1913c"/>
      </linearGradient>
      <linearGradient id="shade" x1="0" y1="0" x2="0" y2="1">
        <stop offset="0%" stop-color="#e8b35c" stop-opacity="0.0"/>
        <stop offset="100%" stop-color="#a96a22" stop-opacity="0.25"/>
      </linearGradient>
      <filter id="soft" x="-20%" y="-20%" width="140%" height="140%">
        <feGaussianBlur stdDeviation="0.6" result="b"/>
        <feBlend in="SourceGraphic" in2="b" mode="normal"/>
      </filter>
    </defs>`;

  function dogSVG(runPhase){ // runPhase: -1 or +1 for alternating legs; null for jump
    const earTilt = runPhase ? 6*runPhase : -8;
    const tailTilt = runPhase ? -10*runPhase : 14;
    const legA = runPhase ? 10*runPhase : 0;
    const legB = runPhase ? -12*runPhase : 0;
    const jumpLift = (runPhase===null) ? -6 : 0;

    return `
    <svg xmlns="http://www.w3.org/2000/svg" width="280" height="176" viewBox="0 0 280 176">
      ${commonDefs}
      <g filter="url(#soft)" stroke="#7a4f26" stroke-width="4" stroke-linecap="round" stroke-linejoin="round">
        <!-- shadow -->
        <ellipse cx="84" cy="144" rx="46" ry="9" fill="rgba(0,0,0,.18)"/>
        <!-- body -->
        <path d="M46,94 q48,-34 110,-18 q28,8 32,24 q-2,22 -36,32 q-58,16 -120,-6 q-4,-16 14,-32 z"
              fill="url(#coat)"/>
        <!-- chest lighter -->
        <path d="M58,104 q18,-16 40,-14 q22,0 28,12 q-4,12 -26,16 q-26,6 -56,-2 q6,-8 14,-12 z"
              fill="url(#shade)" stroke="none"/>
        <!-- head -->
        <g transform="translate(176,82) rotate(${jumpLift})">
          <path d="M0,0 q20,-10 48,-2 q18,6 18,16 q-2,12 -22,16 q-30,6 -52,-6 q2,-14 8,-24 z" fill="url(#coat)"/>
          <!-- ear -->
          <path d="M20,-4 q-10,8 -4,22 q10,10 18,2 q4,-8 -2,-18 z" fill="#dca459"/>
          <!-- eye -->
          <circle cx="44" cy="10" r="4" fill="#1c1c1c"/>
          <!-- nose -->
          <circle cx="62" cy="18" r="4.5" fill="#1c1c1c"/>
          <!-- jaw highlight -->
          <path d="M30,16 q10,6 24,4" stroke="rgba(255,255,255,.35)" stroke-width="3" fill="none"/>
        </g>
        <!-- tail -->
        <path d="M36,92 q-18,-6 -28,-14" transform="rotate(${tailTilt},36,92)"
              fill="none" stroke="#7a4f26"/>
        <!-- legs (front/back) -->
        <g transform="translate(0,${jumpLift})">
          <path d="M92,126 v18" transform="rotate(${legA},92,126)" />
          <circle cx="92" cy="146" r="4" fill="#7a4f26" stroke="none"/>
          <path d="M58,126 v18" transform="rotate(${legB},58,126)" />
          <circle cx="58" cy="146" r="4" fill="#7a4f26" stroke="none"/>
        </g>
      </g>
    </svg>`;
  }

  const runA = new Image();
  runA.src = makeDataURL(dogSVG(-1));
  const runB = new Image();
  runB.src = makeDataURL(dogSVG(1));
  const jumpF = new Image();
  jumpF.src = makeDataURL(dogSVG(null));

  function drawDogSprite(x,y,w,h,vy,onGround,legT){
    // pick frame
    let img;
    if(!onGround){ img = jumpF; }
    else { img = (Math.sin(legT) > 0 ? runA : runB); }
    // tilt a bit with velocity
    const tilt = Math.max(-0.16, Math.min(0.20, vy/1600));
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(tilt);
    ctx.drawImage(img, -w*0.5, -h*0.5, w, h);
    ctx.restore();
  }

  // ---- Poo drawing ----
  function drawPoo(p){
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.fillStyle = 'rgba(0,0,0,.15)';
    ctx.beginPath(); ctx.ellipse(0, -4, p.w*0.35, 5, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--poo').trim() || '#7b4a21';
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--pooEdge').trim() || '#5e3a18';
    ctx.lineWidth = 3*dpr;
    blob(-p.w*0.5, -p.h*0.3, p.w, p.h*0.34, 12);
    blob(-p.w*0.36, -p.h*0.58, p.w*0.72, p.h*0.30, 10);
    blob(-p.w*0.18, -p.h*0.86, p.w*0.36, p.h*0.26, 10);
    ctx.restore();
  }
  function blob(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y, x+w,y+h, r); ctx.arcTo(x+w,y+h, x,y+h, r); ctx.arcTo(x,y+h, x,y, r); ctx.arcTo(x,y, x+w,y, r); ctx.fill(); ctx.stroke(); }

  // ---- Parallax bits ----
  const clouds = new Array(6).fill(0).map((_,i)=>({x: i*360 + Math.random()*240, y: 60+Math.random()*120, r: 20+Math.random()*26 }));
  const hills1 = new Array(5).fill(0).map((_,i)=>({x:i*420, h: 90+Math.random()*40}));
  const hills2 = new Array(5).fill(0).map((_,i)=>({x:i*520, h: 140+Math.random()*60}));
  function drawSky(){
    for (let c of clouds){
      ctx.fillStyle='#fff';
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
      ctx.arc(c.x+c.r*0.9, c.y- c.r*0.5, c.r*0.85, 0, Math.PI*2);
      ctx.arc(c.x+c.r*1.8, c.y, c.r*1.1, 0, Math.PI*2);
      ctx.arc(c.x+c.r*0.9, c.y+c.r*0.5, c.r*0.9, 0, Math.PI*2);
      ctx.fill();
    }
  }
  function drawHills(list, color){
    ctx.fillStyle=color;
    for (let h of list){
      ctx.beginPath();
      ctx.moveTo(h.x-300, groundY);
      ctx.quadraticCurveTo(h.x, groundY-h.h, h.x+300, groundY);
      ctx.closePath(); ctx.fill();
    }
  }
  function drawGround(){
    const root = document.documentElement;
    ctx.fillStyle=getComputedStyle(root).getPropertyValue('--ground').trim()||'#d2c3a4';
    ctx.fillRect(0, groundY, canvas.width, canvas.height-groundY);
    ctx.fillStyle=getComputedStyle(root).getPropertyValue('--grass').trim()||'#9dbc6f';
    ctx.fillRect(0, groundY-6, canvas.width, 6);
    ctx.fillStyle=getComputedStyle(root).getPropertyValue('--track').trim()||'#b6a684';
    const step=28, off=(t*140)%step;
    for(let x=-step;x<canvas.width+step;x+=step) ctx.fillRect(Math.floor(x-off), groundY+8, 14, 6);
  }

  // ---- Game flow & physics (same gameplay as your preferred build) ----
  function reset(){
    state='intro'; t=0; score=0; speed=500;
    minGap=1.4; maxGap=2.0; spawnTimer=0; nextGap=rand(minGap,maxGap);
    poops=[]; dog.x=DOG_X(); dog.y=groundY-dog.h/2; dog.vy=0; dog.onGround=true; dog.legT=0;
    show(intro); hide(over);
    updateHud();
    render(); // intro frame
  }
  function start(){
    state='running'; t=0; score=0; spawnTimer=0; nextGap=rand(minGap,maxGap);
    poops=[]; dog.x=DOG_X(); dog.y=groundY-dog.h/2; dog.vy=0; dog.onGround=true; dog.legT=0;
    hide(intro); hide(over);
  }
  function gameOver(){
    state='over';
    if(score>best){ best=score; localStorage.setItem('bru_best', best); }
    document.getElementById('finalScore').textContent = `Score: ${score} â€¢ Best: ${best}`;
    show(over);
  }

  function spawnPoo(){
    poops.push({ x: canvas.width + 50, y: groundY, w: 52, h: 42 });
    const chance = Math.min(0.60, 0.35 + Math.min(0.25, t*0.0083) + Math.min(0.15, t*0.01));
    if(Math.random() < chance){
      const tight = Math.min(1, t/30);
      const dmin = 54 - 30*tight;
      const dmax = 90 - 42*tight;
      const dx = dmin + Math.random()*(dmax - dmin);
      poops.push({ x: canvas.width + 50 + dx, y: groundY, w: 48, h: 38 });
    }
  }

  function update(dt){
    if(state!=='running') return;
    t += dt;
    // parallax motion
    for (let c of clouds){ c.x -= (520 + t*34)*0.12*dt; if(c.x<-160){ c.x+=canvas.width+360; c.y=40+Math.random()*140; } }
    for (let h of hills2){ h.x -= (520 + t*34)*0.18*dt; if(h.x<-520) h.x+=canvas.width+520; }
    for (let h of hills1){ h.x -= (520 + t*34)*0.24*dt; if(h.x<-420) h.x+=canvas.width+420; }

    // speed ramp & spawn tightening
    speed += dt*34;
    minGap = Math.max(0.35, minGap - dt*0.06);
    maxGap = Math.max(minGap + 0.22, maxGap - dt*0.052);

    // spawning
    spawnTimer += dt;
    if(spawnTimer >= nextGap){ spawnPoo(); spawnTimer=0; nextGap = rand(minGap, maxGap); }

    // physics
    dog.vy += G*dt;
    if(jumpHold && !dog.onGround && holdTime < HOLD_MAX && dog.vy < 0){ dog.vy -= 3000*dt; holdTime+=dt; }
    dog.y += dog.vy*dt;
    dog.legT += dt * (dog.onGround ? (7 + speed*0.0032) : 4.2);
    if(dog.y + dog.h/2 >= groundY){ dog.y = groundY - dog.h/2; dog.vy=0; dog.onGround=true; holdTime=0; }

    // move poos & cull
    for(const p of poops){ p.x -= speed*dt; }
    poops = poops.filter(p => p.x + p.w > 0);

    // collisions
    const dx = dog.x - dog.w/2, dy = dog.y - dog.h/2;
    for(const p of poops){
      const px=p.x, pw=p.w, pyTop=p.y - p.h;
      if(aabb(dx,dy,dog.w,dog.h, px, pyTop, pw, p.h)){ return gameOver(); }
    }

    // score
    score += Math.floor(dt*100);
  }

  function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawSky(); drawHills(hills2, '#c8d4e7'); drawHills(hills1, '#b9d2e8'); drawGround();
    for(const p of poops) drawPoo(p);
    drawDogSprite(dog.x, dog.y, dog.w, dog.h, dog.vy, dog.onGround, dog.legT);
    updateHud();
  }

  function loop(ts){
    const now = ts/1000; if(!loop.last) loop.last = now;
    const dt = Math.max(0, Math.min(now - loop.last, 1/20)); loop.last = now;
    update(dt); render(); requestAnimationFrame(loop);
  }

  function updateHud(){ scoreHud.textContent = `Score: ${score} â€¢ Best: ${best}`; }

  // ---- Input ----
  function press(){ if(state==='intro'){start();return;} if(state==='over'){reset();return;} if(state==='running' && dog.onGround){ dog.vy=-800; dog.onGround=false; jumpHold=true; holdTime=0; } }
  function release(){ jumpHold=false; }
  startBtn.addEventListener('click', start);
  restartBtn.addEventListener('click', reset);
  jumpBtn.addEventListener('click', press);
  canvas.addEventListener('pointerdown', (e)=>{ e.preventDefault(); press(); }, {passive:false});
  canvas.addEventListener('pointerup', (e)=>{ e.preventDefault(); release(); }, {passive:false});
  window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); press(); }}, {passive:false});
  window.addEventListener('keyup',   (e)=>{ if(e.code==='Space'){ e.preventDefault(); release(); }}, {passive:false});

  // ---- Boot ----
  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
