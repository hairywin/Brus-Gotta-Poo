<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<title>Brus Gotta Poo! (v1.4 Hard‑coded Frames)</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  :root {
    --skyTop:#bfe4ff; --skyMid:#d9efff; --skyBot:#fdeedb;
    --sun:#fff7b2;
    --hillBack:#c8d4e7; --hillFront:#b6c9e3;
    --groundBase:#dfd3b9; --groundShade:#c9b99a; --grass:#8fbe63; --path:#b49a77;
  }
  *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
  html,body{height:100%;margin:0;background:var(--skyBot);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{position:fixed;inset:0;display:grid;grid-template-rows:1fr auto}
  canvas{width:100%;height:100%;display:block;touch-action:manipulation;background:linear-gradient(var(--skyTop),var(--skyMid) 55%, var(--skyBot))}
  .hud{display:flex;gap:10px;align-items:center;justify-content:center;padding:8px env(safe-area-inset-right) calc(8px + env(safe-area-inset-bottom)) env(safe-area-inset-left);background:linear-gradient(180deg,#0000,#0001)}
  .btn{border:0;border-radius:12px;padding:10px 14px;background:var(--accent,#ffd54f);font-weight:800;color:#3a300e}
  .btn:active{transform:translateY(1px) scale(.99)}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
  .card{background:var(--card,#263238ee);color:var(--text,#fff);padding:22px 28px;border-radius:18px;box-shadow:0 14px 40px #0006;text-align:center;max-width:min(560px,86vw)}
  .title{font-size:28px;font-weight:900;margin:0 0 6px 0}
  .subtitle{font-size:18px;opacity:.95;margin:0 0 12px 0}
  .hidden{display:none!important}
  .scoreHud{position:fixed;left:12px;top:8px;background:rgba(0,0,0,.25);color:#fff;padding:10px 12px;border-radius:12px;font-weight:700;z-index:20}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="900" height="420" aria-label="Brus Gotta Poo! Endless Runner"></canvas>

  <div id="intro" class="overlay">
    <div class="card">
      <div class="title">Brus Gotta Poo!</div>
      <div class="subtitle">Tap to Begin — v1.4</div>
      <button id="startBtn" class="btn">Start</button>
    </div>
  </div>

  <div id="gameOver" class="overlay hidden">
    <div class="card">
      <div class="title">Game Over 💩</div>
      <div id="finalScore" class="subtitle"></div>
      <button id="restartBtn" class="btn">Restart</button>
    </div>
  </div>

  <div id="scoreHud" class="scoreHud">Score 🦴: 0 • Best: 0</div>
  <div class="hud">
    <button id="jumpBtn" class="btn">Jump (Tap/Space)</button>
    <button id="debugBtn" class="btn" title="Toggle debug (D)">Debug (D)</button>
    <span class="subtitle" style="color:#000;opacity:.75">
      Quick taps = small hops, hold for higher jumps. Double jump enabled. Press <b>D</b> for debug.
    </span>
  </div>
</div>

<script>
(()=>{
  const VERSION = 'v1.4 Hard-coded Frames';
  console.log('Brus Gotta Poo! ' + VERSION);

  // Canvas & sizing
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  canvas.tabIndex = 0; // allow keyboard focus
  canvas.style.outline = 'none';

function currentZoom(){
  const smallScreen = window.matchMedia('(max-width: 820px)').matches;
  const portrait = window.matchMedia('(orientation: portrait)').matches;
  if(!smallScreen) return 1.25; // zoom IN 15% on laptop/desktop
  return portrait ? 0.92 : 0.96; // unchanged on iPhone/small screens
}


  let dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
  let zoom = currentZoom();
  let groundY = canvas.height * 0.80;

  function resize(){
    dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    zoom = currentZoom();
    canvas.width  = Math.floor(window.innerWidth  * dpr / zoom);
    canvas.height = Math.floor(window.innerHeight * dpr / zoom);
    groundY = canvas.height * 0.80;
  }
  window.addEventListener('resize', resize, {passive:true});
  window.addEventListener('orientationchange', resize, {passive:true});
  resize();

  // DOM
  const intro = document.getElementById('intro');
  const over  = document.getElementById('gameOver');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const jumpBtn = document.getElementById('jumpBtn');
  const debugBtn = document.getElementById('debugBtn');
  const scoreHud = document.getElementById('scoreHud');
  const show = el => el.classList.remove('hidden');
  const hide = el => el.classList.add('hidden');

  // State
  let state='intro', t=0, score=0, best=parseInt(localStorage.getItem('bru_best')||'0',10);
  const G = 3000;
  let jumpHold=false, holdTime=0, speed=500;
let poops=[];
let debugSlices = false;
let tripleFlash = { show: 0, rect: null }; // debug: flash expanded poo rect when triple is available
let tripleGrace = 0; // seconds left to still allow triple after window closes



// Double jump settings (+ conditional emergency triple)
const MAX_JUMPS   = 2;
const JUMP_V0_1   = -800;  // first jump power
const JUMP_V0_2   = -720;  // second jump slightly weaker
const HOLD_MAX_1  = 0.18;  // first jump hold cap
const HOLD_MAX_2  = 0.12;  // second jump hold cap
let jumpsLeft = MAX_JUMPS;
let jumpPhase = 0; // 0=none, 1=first, 2=second, 3=emergency triple

// Emergency triple jump tuning (earlier & easier)
const EMERGENCY_LAND_WINDOW = 125; // trigger farther from the ground
const EMERGENCY_AHEAD_MIN   = -14; // allow slight overlap
const EMERGENCY_AHEAD_MAX   = 150; // count poo farther ahead
const EMERGENCY_PROXIMITY   = 72;  // bigger “super close” bubble
const EMERGENCY_V0          = -720; // third jump power (tune feel)
const EMERGENCY_HOLD_MAX    = 0.10; // brief hold for triple
const EMERGENCY_GRACE       = 0.18; // seconds you can still trigger after window




  // Runner
  const dog={ x:0, y:0, w:160, h:112, vy:0, onGround:true, frame:0 };
  const DOG_X = ()=> canvas.width*0.2;

  // Spawning
  let minGap=1.4, maxGap=2.0, spawnTimer=0, nextGap=rand(minGap,maxGap);
  function rand(a,b){ return a + Math.random()*(b-a); }

  // Assets — HARD-CODED SPRITE LAYOUT (4×2, 256×176)
  const rawImg = new Image(); rawImg.src = 'bru_sprite.png';
let cleanSprite=null, frameW=379.5, frameH=318, cols=4, rows=2, totalFrames=8;
  let frameRect=null; // function(i) => {sx, sy, sw, sh}

  rawImg.onload = ()=>{
    // Use the sprite as-is (transparent padding already baked in)
    cleanSprite = rawImg;

    // Fixed slicer
    frameRect = function(i){
      const c = i % cols;
      const r = Math.floor(i / cols);
      const sx = c * frameW;
      const sy = r * frameH;
      return { sx, sy, sw: frameW, sh: frameH };
    };

    // Size dog based on frame aspect
    const frameAspect = frameH / frameW; // 176 / 256 = 0.6875
    dog.w = 160;
    dog.h = Math.round(dog.w * frameAspect);
  };

// Poo obstacle image
const foodImg = new Image();
foodImg.src = 'poo.png';
  let foodReady = false;
  foodImg.onload = () => { foodReady = true; };

  // Parallax sky elements
  const sun = { x: () => canvas.width*0.82, y: () => canvas.height*0.18, r: 36*dpr };
  const clouds = new Array(7).fill(0).map((_,i)=>({x: i*420 + Math.random()*240, y: 60+Math.random()*120, r: 20+Math.random()*26 }));
  const hillsBack = new Array(6).fill(0).map((_,i)=>({x:i*520, h: 140+Math.random()*60}));
  const hillsFront= new Array(6).fill(0).map((_,i)=>({x:i*420, h: 90+Math.random()*40}));

  // Flow
  function reset(){
    state='intro'; t=0; score=0; speed=500;
    minGap=1.4; maxGap=2.0; spawnTimer=0; nextGap=rand(minGap,maxGap);
    poops=[]; dog.x=DOG_X(); dog.y=groundY-dog.h/2; dog.vy=0; dog.onGround=true; dog.frame=0;
    jumpsLeft = MAX_JUMPS; jumpPhase = 0; jumpHold=false; holdTime=0;
    show(intro); hide(over); updateHud(); render();
  }
  function start(){
    state='running'; t=0; score=0; spawnTimer=0; nextGap=rand(minGap,maxGap);
    poops=[]; dog.x=DOG_X(); dog.y=groundY-dog.h/2; dog.vy=0; dog.onGround=true; dog.frame=0;
    jumpsLeft = MAX_JUMPS; jumpPhase = 0; jumpHold=false; holdTime=0;
    hide(intro); hide(over);
  }
  function gameOver(){
    state='over'; if(score>best){ best=score; localStorage.setItem('bru_best',best); }
    document.getElementById('finalScore').textContent = `Score: ${score} • Best: ${best}`;
    show(over);
  }

  function spawnPoo(){
poops.push({ x: canvas.width + 50, y: groundY + 22, w: 52, h: 42, a: Math.random()*Math.PI*2 });
    const chance = Math.min(0.60, 0.35 + Math.min(0.25, t*0.0083) + Math.min(0.15, t*0.01));
    if(Math.random() < chance){
      const tight = Math.min(1, t/30);
      const dmin = 54 - 30*tight;
      const dmax = 90 - 42*tight;
      const dx = dmin + Math.random()*(dmax - dmin);
poops.push({ x: canvas.width + 50 + dx, y: groundY + 22, w: 48, h: 38, a: Math.random()*Math.PI*2 });
    }
  }

  // Double jump helpers
  function doJump(){
    jumpPhase = dog.onGround ? 1 : Math.min(2, jumpPhase + 1);
    const v0 = (jumpPhase === 1) ? JUMP_V0_1 : JUMP_V0_2;
    dog.vy = v0;
    dog.onGround = false;
    jumpHold = true;
    holdTime = 0;
  }
function canEmergencyTriple(){
  // Must have already used the double jump, be airborne
  if (jumpPhase !== 2 || dog.onGround) return false;

  // Earlier eligibility near apex: allow while still rising a bit
  if (dog.vy < -120) return false; // was -40

  // Last‑chance: close-ish to ground (but we’ve loosened it via constants)
  const distToGround = groundY - (dog.y + dog.h/2);
  if (distToGround > EMERGENCY_LAND_WINDOW) {
    // Window not live — but if we recently had it, allow during grace
    return tripleGrace > 0;
  }

  // Player bounds
  const dogLeft   = dog.x - dog.w/2;
  const dogRight  = dog.x + dog.w/2;
  const dogTop    = dog.y - dog.h/2;
  const dogBottom = dog.y + dog.h/2;

  let hitRect = null;

  for (const p of poops){
    // Poo rect (center x, bottom y)
    const pooLeft   = p.x - p.w/2;
    const pooRight  = p.x + p.w/2;
    const pooTop    = p.y - p.h;
    const pooBottom = p.y;

    // Expanded “super close” rect
    const exLeft   = pooLeft   - EMERGENCY_PROXIMITY;
    const exRight  = pooRight  + EMERGENCY_PROXIMITY;
    const exTop    = pooTop    - EMERGENCY_PROXIMITY;
    const exBottom = pooBottom + EMERGENCY_PROXIMITY;

    // Overlap check
    const overlaps =
      dogRight  >= exLeft  &&
      dogLeft   <= exRight &&
      dogBottom >= exTop   &&
      dogTop    <= exBottom;
    if (!overlaps) continue;

    // Require “in front or barely overlapping”
    const ahead = pooLeft - dogRight; // negative = slightly inside our nose already
    if (ahead < EMERGENCY_AHEAD_MIN || ahead > EMERGENCY_AHEAD_MAX) continue;

    // Record debug rect + arm grace
    hitRect = { l: exLeft, t: exTop, r: exRight, b: exBottom };
    tripleGrace = EMERGENCY_GRACE; // give a few frames to press
    break;
  }

  if (hitRect){
    if (debugSlices){
      tripleFlash.show = 0.08; // ~5 frames
      tripleFlash.rect = hitRect;
    }
    return true;
  }

  // If we just left the window, allow during grace
  return tripleGrace > 0;
}




function doEmergencyTriple(){
  // Promote to phase 3, give a jump with a slightly smaller hold window
  jumpPhase = 3;
  dog.vy = EMERGENCY_V0;
  dog.onGround = false;
  jumpHold = true;
  holdTime = 0;

  // Temporarily override the hold window just for this jump
  // We'll swap it back in update() by keying off jumpPhase===3
}


  // Update
  function update(dt){
    if(state!=='running') return;
t+=dt;
if (tripleGrace > 0) tripleGrace -= dt;

    // Parallax motion
    for (let c of clouds){ c.x -= (520 + t*34)*0.10*dt; if(c.x<-220){ c.x+=canvas.width+480; c.y=40+Math.random()*160; } }
    for (let h of hillsBack){ h.x -= (520 + t*34)*0.16*dt; if(h.x<-520) h.x+=canvas.width+520; }
    for (let h of hillsFront){ h.x -= (520 + t*34)*0.22*dt; if(h.x<-420) h.x+=canvas.width+420; }

    // Speed + spawn tightening
    speed += dt*34;
    minGap = Math.max(0.35, minGap - dt*0.06);
    maxGap = Math.max(minGap + 0.22, maxGap - dt*0.052);

    // Spawning
    spawnTimer += dt; if(spawnTimer >= nextGap){ spawnPoo(); spawnTimer=0; nextGap = rand(minGap, maxGap); }

    // Physics
    dog.vy += G*dt;
const holdCap = (jumpPhase === 1) ? HOLD_MAX_1
               : (jumpPhase === 2) ? HOLD_MAX_2
               : EMERGENCY_HOLD_MAX; // jumpPhase === 3
    if(jumpHold && !dog.onGround && holdTime < holdCap && dog.vy < 0){ dog.vy -= 3000*dt; holdTime+=dt; }
    dog.y += dog.vy*dt;

if(dog.y + dog.h/2 >= groundY){
  dog.y = groundY - dog.h/2 + 6; // lowered 6px
  dog.vy = 0;
  if(!dog.onGround){ jumpsLeft = MAX_JUMPS; jumpPhase = 0; }
  dog.onGround = true;
  holdTime = 0;
  tripleGrace = 0;              // <- clear grace on landing
  tripleFlash.show = 0;         // <- clear any debug flash
}

    // Move obstacles
    for(const p of poops){ p.x -= speed*dt; p.a += dt*1.8; }
    poops = poops.filter(p => p.x + p.w > 0);

    // Collisions
    const dx = dog.x - dog.w/2, dy = dog.y - dog.h/2;
    for(const p of poops){
      const px=p.x, pw=p.w, pyTop=p.y - p.h;
      if(dx < px + pw && dx + dog.w > px && dy < p.y && dy + dog.h > pyTop){ return gameOver(); }
    }

    // Score
    score += Math.floor(dt*100);
  }

  // Draw helpers
  function drawHills(list, color){
    ctx.fillStyle=color;
    for (let h of list){
      ctx.beginPath();
      ctx.moveTo(h.x-320, groundY);
      ctx.quadraticCurveTo(h.x, groundY-h.h, h.x+320, groundY);
      ctx.closePath(); ctx.fill();
    }
  }
  function drawSky(){
    const x=sun.x(), y=sun.y(), r=sun.r;
    const g = ctx.createRadialGradient(x, y, 0, x, y, r*3);
    g.addColorStop(0, 'rgba(255,247,178,0.9)');
    g.addColorStop(1, 'rgba(255,247,178,0)');
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r*3,0,Math.PI*2); ctx.fill();
    for (let c of clouds){
      ctx.fillStyle='rgba(255,255,255,0.95)';
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
      ctx.arc(c.x+c.r*0.9, c.y- c.r*0.5, c.r*0.85, 0, Math.PI*2);
      ctx.arc(c.x+c.r*1.8, c.y, c.r*1.1, 0, Math.PI*2);
      ctx.arc(c.x+c.r*0.9, c.y+c.r*0.5, c.r*0.9, 0, Math.PI*2);
      ctx.fill();
    }
    drawHills(hillsBack, getComputedStyle(document.documentElement).getPropertyValue('--hillBack').trim()||'#c8d4e7');
    drawHills(hillsFront,getComputedStyle(document.documentElement).getPropertyValue('--hillFront').trim()||'#b6c9e3');
  }
  function drawGround(){
    const base = getComputedStyle(document.documentElement).getPropertyValue('--groundBase').trim()||'#dfd3b9';
    const shade= getComputedStyle(document.documentElement).getPropertyValue('--groundShade').trim()||'#c9b99a';
    const grd = ctx.createLinearGradient(0,  groundY, 0, canvas.height);
    grd.addColorStop(0, shade); grd.addColorStop(1, base);
    ctx.fillStyle=grd; ctx.fillRect(0, groundY, canvas.width, canvas.height-groundY);

    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--grass').trim()||'#8fbe63';
    ctx.fillRect(0, groundY-8, canvas.width, 8);

    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--path').trim()||'#b49a77';
    const step=28, off=(t*140)%step;
    for(let x=-step;x<canvas.width+step;x+=step) ctx.fillRect(Math.floor(x-off), groundY+10, 14, 6);

const seed = Math.floor(t*2);
const shrubSpacing = 120;
const shrubCount = Math.ceil((canvas.width + shrubSpacing) / shrubSpacing) + 1;

const phase = (seed * 53) % shrubSpacing;
const drift = (t * 60) % shrubSpacing;

// tiny deterministic "random"
const rand = (n) => {
  const s = Math.sin(n * 12.9898 + 78.233) * 43758.5453;
  return s - Math.floor(s);
};

for (let i = 0; i < shrubCount; i++) {
  const gx = (i * shrubSpacing + phase + drift) % (canvas.width + shrubSpacing) - shrubSpacing / 2;
  const gy = groundY - 8;

  // stable per-shrub variation while it’s on screen
  const worldIndex = i + Math.floor((phase + drift) / shrubSpacing);

const hScale = 0.60 + rand(worldIndex) * 1.00;        // 0.60–1.60 (much wider)
const tilt   = (rand(worldIndex + 0.5) - 0.5) * 0.60; // bigger lean


  ctx.save();
  ctx.translate(gx, gy);
  ctx.rotate(tilt);

  ctx.strokeStyle = '#2f6d1f';
  ctx.lineWidth = 2 * dpr;

  const blade1 = 10 * hScale;
  const blade2 = 12 * hScale;

  // left blade
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(6 * hScale, -blade1, 2 * hScale, -2 * hScale);

  // right blade
  ctx.moveTo(10 * hScale, 0);
  ctx.quadraticCurveTo(16 * hScale, -blade2, 12 * hScale, -2 * hScale);
  ctx.stroke();

  // no flowers on shrubs

  ctx.restore();
}


  }
  function drawPoo(p){
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.fillStyle='rgba(0,0,0,.18)';
    ctx.beginPath();
    ctx.ellipse(0, -6, p.w*0.42, 7, 0, 0, Math.PI*2);
    ctx.fill();

    if (foodReady){
      const iw = foodImg.naturalWidth || foodImg.width || 1;
      const ih = foodImg.naturalHeight || foodImg.height || 1;
      const aspect = ih / iw;
      const targetW = p.w * 2.2;
      const targetH = targetW * aspect;
      const wobble = Math.sin(p.a * 0.8) * 0.08;
      ctx.rotate(wobble);
const yOffset = -Math.max(targetH, p.h * 0.95) + 6; // tiny visual drop
      ctx.drawImage(foodImg, -targetW/2, yOffset, targetW, targetH);
    } else {
      ctx.fillStyle = '#888';
      ctx.fillRect(-p.w*0.5, -p.h, p.w, p.h);
    }
    ctx.restore();
  }
  function drawDog(){
    if(!cleanSprite){ return; }
    const tilt = Math.max(-0.12, Math.min(0.16, dog.vy/1600));
    ctx.save(); ctx.translate(dog.x, dog.y); ctx.rotate(tilt);
    const fps = 6; dog.frame = (dog.frame + fps/60) % totalFrames;
    const frameIndex = dog.onGround ? Math.floor(dog.frame) : 2;

    const { sx, sy, sw, sh } = frameRect(frameIndex);
    ctx.drawImage(cleanSprite, sx, sy, sw, sh, -dog.w*0.5, -dog.h*0.5, dog.w, dog.h);
    ctx.restore();
  }

  // Debug overlay (toggle with D)
function drawDebug(){
  if (!cleanSprite) return;
  ctx.save();

  // Banner
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(8, 8, 290, 26);
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#fff';
  ctx.font = `${14*dpr}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
  ctx.fillText('DEBUG: slice overlay ON (press D)', 14, 26);

  // Dog bounds
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 2*dpr;
  ctx.strokeRect(dog.x - dog.w/2, dog.y - dog.h/2, dog.w, dog.h);

  // Sprite sheet mini preview with grid + current frame (4×2, 384×512)
  const padX = 10, padY = 42;
  const sheetW = Math.min(260, canvas.width * 0.32);
  const scale  = sheetW / cleanSprite.width; // cleanSprite should be 1024 wide
  const sheetH = cleanSprite.height * scale; // 352 high
  ctx.drawImage(cleanSprite, padX, padY, sheetW, sheetH);

  // Grid lines
  ctx.strokeStyle = 'rgba(255,0,0,0.75)';
  ctx.lineWidth = 1*dpr;
  for (let c = 1; c < cols; c++){
    const x = padX + Math.round((c * frameW) * scale);
    ctx.beginPath(); ctx.moveTo(x, padY); ctx.lineTo(x, padY + sheetH); ctx.stroke();
  }
  for (let r = 1; r < rows; r++){
    const y = padY + Math.round((r * frameH) * scale);
    ctx.beginPath(); ctx.moveTo(padX, y); ctx.lineTo(padX + sheetW, y); ctx.stroke();
  }

  // Highlight current frame
  const frameIndex = dog.onGround ? Math.floor(dog.frame) : 2;
  const sx = (frameIndex % cols) * frameW;
  const sy = Math.floor(frameIndex / cols) * frameH;
  ctx.strokeStyle = 'yellow';
  ctx.lineWidth = 2*dpr;
  ctx.strokeRect(padX + sx * scale, padY + sy * scale, frameW * scale, frameH * scale);

  // === Triple-jump proximity box (live, no button press needed) ===
  if (!dog.onGround && jumpPhase === 2) {
const descendingSoon = (dog.vy >= -120); // earlier window near apex (matches trigger)
    const distToGround = groundY - (dog.y + dog.h/2);
    if (descendingSoon && distToGround <= EMERGENCY_LAND_WINDOW) {
      const dogLeft   = dog.x - dog.w/2;
      const dogRight  = dog.x + dog.w/2;
      const dogTop    = dog.y - dog.h/2;
      const dogBottom = dog.y + dog.h/2;

      for (const p of poops){
        const pooLeft   = p.x - p.w/2;
        const pooRight  = p.x + p.w/2;
        const pooTop    = p.y - p.h;
        const pooBottom = p.y;

        const exLeft   = pooLeft   - EMERGENCY_PROXIMITY;
        const exRight  = pooRight  + EMERGENCY_PROXIMITY;
        const exTop    = pooTop    - EMERGENCY_PROXIMITY;
        const exBottom = pooBottom + EMERGENCY_PROXIMITY;

        const overlaps =
          dogRight  >= exLeft  &&
          dogLeft   <= exRight &&
          dogBottom >= exTop   &&
          dogTop    <= exBottom;

        const ahead = pooLeft - dogRight; // negative = slightly overlapping already
        const okayAhead = (ahead >= EMERGENCY_AHEAD_MIN && ahead <= EMERGENCY_AHEAD_MAX);

        if (overlaps && okayAhead){
          ctx.save();
          ctx.lineWidth = 3 * dpr;
          ctx.strokeStyle = '#00ff88';
          ctx.strokeRect(exLeft, exTop, exRight - exLeft, exBottom - exTop);
          ctx.restore();
          break; // draw only the first qualifying poo
        }
      }
    }
  }


  ctx.restore();
}


  function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawSky(); drawGround();
    for(const p of poops) drawPoo(p);
    drawDog();
    updateHud();
if (debugSlices) drawDebug();

  }
  function updateHud(){ scoreHud.textContent = `Score 🦴: ${score} • Best: ${best}`; }

  function loop(ts){
    const now = ts/1000; if(!loop.last) loop.last = now;
    const dt = Math.max(0, Math.min(now - loop.last, 1/20)); loop.last = now;
    if(state==='running'){ update(dt); }
    render(); requestAnimationFrame(loop);
  }

  // Input
 function press(){
  if(state==='intro'){ start(); return; }
  if(state==='over'){ reset(); return; }

  if(state==='running'){
    if(dog.onGround){ jumpsLeft = MAX_JUMPS; }

    if(dog.onGround || jumpsLeft > 0){
      // Normal single/double jump path
      doJump();
      if(!dog.onGround){ jumpsLeft--; } else { jumpsLeft = MAX_JUMPS - 1; }
      return;
    }

    // No jumps left? Check emergency triple condition.
    if (canEmergencyTriple()){
      doEmergencyTriple();
      return;
    }
  }
}

  function release(){ jumpHold=false; }
  startBtn.addEventListener('click', start);
  restartBtn.addEventListener('click', reset);
  jumpBtn.addEventListener('click', press);
  debugBtn.addEventListener('click', ()=>{ debugSlices = !debugSlices; console.log('DEBUG overlay:', debugSlices ? 'ON' : 'OFF'); });
  canvas.addEventListener('pointerdown', e=>{ e.preventDefault(); press(); }, {passive:false});
  canvas.addEventListener('pointerup',   e=>{ e.preventDefault(); release(); }, {passive:false});

  window.addEventListener('keydown', e=>{
    if(e.code==='Space'){ e.preventDefault(); press(); }
  }, {passive:false});
  window.addEventListener('keyup',   e=>{
    if(e.code==='Space'){ e.preventDefault(); release(); }
  }, {passive:false});

  // Robust D toggle: single listener + no repeats
  let dPressed = false;
  function debugKeyHandler(e){
    const k = (e.code || e.key || '').toLowerCase();
    if (k === 'keyd' || k === 'd'){
      if (e.repeat || dPressed) return; // prevent double toggle
      e.preventDefault();
      dPressed = true;
      debugSlices = !debugSlices;
      console.log('DEBUG overlay:', debugSlices ? 'ON' : 'OFF');
    }
  }
  window.addEventListener('keydown', debugKeyHandler, { capture: true });
  window.addEventListener('keyup', (e)=>{
    const k = (e.code || e.key || '').toLowerCase();
    if (k === 'keyd' || k === 'd') dPressed = false;
  }, { capture: true });

  // Boot
  reset(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
