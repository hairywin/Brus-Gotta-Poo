<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<title>Brus Gotta Poo!</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  :root {
    --bg1:#cde7ff; --bg2:#f7efe3; --text:#2b2b2b;
    --ground:#d2c3a4; --grass:#9dbc6f; --track:#b6a684;
    --poo:#7b4a21; --pooEdge:#5e3a18;
  }
  * { box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  html,body { height:100%; margin:0; background:var(--bg2); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  .wrap { position:fixed; inset:0; display:grid; grid-template-rows: 1fr auto; }
  canvas { width:100%; height:100%; display:block; touch-action: manipulation; }
  .hud { display:flex; gap:10px; align-items:center; justify-content:center; padding:8px env(safe-area-inset-right) calc(8px + env(safe-area-inset-bottom)) env(safe-area-inset-left); background: linear-gradient(180deg, #0000, #0001); }
  .btn { border:0; border-radius:12px; padding:12px 16px; background:#ffd54f; font-weight:800; color:#3a300e; font-size:16px; }
  .btn:active { transform: translateY(1px) scale(.99); }
  .muted { opacity:.8; font-size:14px; }
  .overlay {
    position: absolute; inset: 0; display: none;
    align-items: center; justify-content: center; flex-direction: column; gap: 12px;
    background: rgba(0,0,0,.45); color: #fff; text-align: center; padding: 20px;
  }
  .overlay.show { display: flex; }
  .title { font-size: 28px; font-weight: 900; }
  .subtitle { font-size: 18px; opacity: .95; }
  .error { position: absolute; left: 8px; right: 8px; bottom: 72px; padding: 10px; background:#ffebee; color:#b71c1c; border-radius: 10px; display:none; }
  .error.show { display:block; }
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="900" height="420" aria-label="Brus Gotta Poo! Endless Runner"></canvas>
  <div id="intro" class="overlay show">
    <div class="title">Brus Gotta Poo!</div>
    <div class="subtitle">Tap to Begin</div>
    <button id="bigStart" class="btn">Start</button>
  </div>
  <div id="pause" class="overlay">
    <div class="title">Paused</div>
    <div class="subtitle">Tap or press P to resume</div>
    <button id="bigResume" class="btn">Resume</button>
  </div>
  <div id="gameover" class="overlay">
    <div class="title">Game Over ðŸ’©</div>
    <div class="subtitle" id="scoreline">Score: 0 â€¢ Best: 0</div>
    <button id="bigRestart" class="btn">Restart</button>
  </div>
  <div id="err" class="error"></div>
  <div class="hud">
    <button id="startBtn" class="btn">Start / Jump (Tap/Space)</button>
    <button id="pauseBtn" class="btn" style="background:#b3e5fc;color:#0a2a3a">Pause (P)</button>
    <span class="muted">Quick taps = small hops, hold for higher jumps. Avoid the ðŸ’©!</span>
  </div>
</div>
<script>
try {
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const intro = document.getElementById('intro');
  const pauseOv = document.getElementById('pause');
  const overOv = document.getElementById('gameover');
  const scoreline = document.getElementById('scoreline');
  const bigStart = document.getElementById('bigStart');
  const bigResume = document.getElementById('bigResume');
  const bigRestart = document.getElementById('bigRestart');
  const errBox = document.getElementById('err');

  function showErr(msg){ errBox.textContent = msg; errBox.classList.add('show'); }

  function fit() {
    const ratio = Math.min(window.devicePixelRatio || 1.5, 2);
    const cssW = window.innerWidth;
    const cssH = window.innerHeight - 64; // hud
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(cssW * ratio);
    canvas.height = Math.round(cssH * ratio);
    scale = ratio;
  }
  let scale = 1;
  window.addEventListener('resize', fit, {passive:true});
  fit();

  const GROUND_Y = ()=> canvas.height * 0.78;
  const GRAVITY = 2900;
  const JUMP_V0 = -760;
  const HOLD_ACCEL = -3200;
  const HOLD_MAX = 0.18;
  const SCROLL_BASE = 520;
  const SPEED_TIME_INC = 44;
  const SPEED_SCORE_INC = 14;
  const DOG_X = ()=>canvas.width*0.2;

  let running=false, paused=false, last=0, t=0, score=0, shakeT=0, best=parseInt(localStorage.getItem('bru_best')||'0',10);
  let dog, obstacles, clouds, hills1, hills2, particles=[], gameOver=false;
  let jumpHeld=false;

  // simple SVG sprite (single frame) so nothing external can fail
  const dogImg = new Image();
  dogImg.src = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="180" height="120" viewBox="0 0 180 120"><defs><linearGradient id="c" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#d79a4a"/><stop offset="100%" stop-color="#b5772f"/></linearGradient><linearGradient id="b" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#f5d39a"/><stop offset="100%" stop-color="#e7b96c"/></linearGradient></defs><g stroke="%23744a22" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><rect x="32" y="38" rx="18" ry="18" width="76" height="44" fill="url(%23c)"/><rect x="58" y="58" rx="10" ry="10" width="34" height="20" fill="url(%23b)" stroke="none"/><rect x="98" y="34" rx="14" ry="14" width="40" height="36" fill="url(%23c)"/><rect x="116" y="50" rx="8" ry="8" width="22" height="16" fill="url(%23b)"/><circle cx="138" cy="58" r="4" fill="%232b2b2b" stroke="none"/><path d="M106,40 Q96,56 110,66 Q112,56 106,40 Z" fill="url(%23c)"/><circle cx="122" cy="50" r="3.2" fill="%231a1a1a" stroke="none"/><path d="M32,58 Q16,44 8,58" fill="none"/></g></svg>';

  function reset() {
    running=false; paused=false; gameOver=false; t=0; score=0; jumpHeld=false; shakeT=0;
    dog = { x:DOG_X(), y:GROUND_Y()-64, vy:0, w:132, h:88, onGround:true, legT:0, jumpHoldT:0 };
    obstacles=[];
    clouds = new Array(6).fill(0).map((_,i)=>({x: i*320 + Math.random()*220, y: 60+Math.random()*130, s: 18+Math.random()*24 }));
    hills1 = new Array(5).fill(0).map((_,i)=>({x:i*400, h: 90+Math.random()*40}));
    hills2 = new Array(5).fill(0).map((_,i)=>({x:i*500, h: 140+Math.random()*60}));
    spawnObstacle(canvas.width + 900 + Math.random()*400); // long runway
    showIntro();
    render(); // draw once
  }

  function start(){ if(running && !gameOver) return; running=true; gameOver=false; paused=false; last=performance.now(); hideAll(); requestAnimationFrame(loop); }
  function pause(){ if(!running || gameOver) return; paused=true; showPause(); }
  function resume(){ if(!running || gameOver) return; paused=false; last=performance.now(); hideAll(); requestAnimationFrame(loop); }

  function pressJump(){ if(!running){ start(); return; } if(paused||gameOver) return;
    if(dog.onGround){ dog.vy = JUMP_V0; dog.onGround=false; dog.jumpHoldT=0; jumpHeld=true; }
  }
  function releaseJump(){ jumpHeld=false; }

  function spawnObstacle(startX){
    const size = 34 + Math.random()*26;
    obstacles.push({ x:startX, y:GROUND_Y(), w:size*1.3, h:size, passed:false });
    if(Math.random()<0.28){ const gap= 170+Math.random()*70;
      obstacles.push({ x:startX+gap, y:GROUND_Y(), w:size*1.15, h:size*0.95, passed:false });
    }
  }

  function loop(now){
    if(!running || paused) return;
    const dt = Math.min((now-last)/1000, 1/30);
    last = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  function update(dt){
    t += dt;
    const speed = SCROLL_BASE + t*44 + score*14;

    dog.vy += GRAVITY * dt;
    if(jumpHeld && !dog.onGround && dog.jumpHoldT < 0.18 && dog.vy < 0){ dog.vy += -3200*dt; dog.jumpHoldT+=dt; }
    dog.y += dog.vy * dt;
    dog.legT += dt * (dog.onGround ? (7 + speed*0.0032) : 4.2);
    if(dog.y + dog.h/2 >= GROUND_Y()){ dog.y=GROUND_Y()-dog.h/2; if(!dog.onGround) { shakeT=0.08; } dog.vy=0; dog.onGround=true; dog.jumpHoldT=0; }

    for (let c of clouds){ c.x -= speed*0.12*dt; if(c.x<-160){ c.x+=canvas.width+360; c.y=40+Math.random()*140; } }
    for (let h of hills2){ h.x -= speed*0.18*dt; if(h.x<-520) h.x+=canvas.width+520; }
    for (let h of hills1){ h.x -= speed*0.24*dt; if(h.x<-420) h.x+=canvas.width+420; }

    if(obstacles.length===0 || obstacles[obstacles.length-1].x < canvas.width - 560){ spawnObstacle(canvas.width + 280 + Math.random()*280); }
    for (let o of obstacles){ o.x -= speed * dt; if(!o.passed && o.x + o.w/2 < dog.x - dog.w/2){ o.passed=true; score++; } }
    if(obstacles.length && obstacles[0].x + obstacles[0].w < -60) obstacles.shift();

    const dogBox = {x:dog.x-dog.w*0.30, y:dog.y-dog.h*0.44, w:dog.w*0.60, h:dog.h*0.88};
    for (let o of obstacles){
      const ob = {x:o.x-o.w*0.5, y:o.y-o.h, w:o.w, h:o.h};
      if(aabb(dogBox, ob)) return gameOverState();
    }

    if(shakeT>0) shakeT = Math.max(0, shakeT - dt);
  }

  function aabb(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

  function render(){
    if(shakeT>0){ ctx.save(); ctx.translate( (Math.random()*2-1)*6*scale, (Math.random()*2-1)*4*scale ); }
    drawSky();
    drawHills(hills2, '#c8d4e7');
    drawHills(hills1, '#b9d2e8');
    drawGround();
    for (let o of obstacles) drawPoo(o);
    drawDog();
    drawScore();
    if(shakeT>0) ctx.restore();
  }

  function drawSky(){
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,'#cde7ff'); g.addColorStop(1,'#f7efe3');
    ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
    for (let c of clouds) drawCloud(c.x, c.y, c.s);
  }
  function drawHills(list, color){
    ctx.fillStyle=color;
    const y=GROUND_Y();
    for (let h of list){
      ctx.beginPath();
      ctx.moveTo(h.x-300, y);
      ctx.quadraticCurveTo(h.x, y-h.h, h.x+300, y);
      ctx.closePath(); ctx.fill();
    }
  }
  function drawGround(){
    const y=GROUND_Y();
    ctx.fillStyle='var(--ground)'; ctx.fillRect(0, y, canvas.width, canvas.height-y);
    ctx.fillStyle='var(--grass)'; ctx.fillRect(0, y-6, canvas.width, 6);
    ctx.fillStyle='var(--track)';
    const step=28, off=(t*140)%step;
    for(let x=-step;x<canvas.width+step;x+=step) ctx.fillRect(Math.floor(x-off), y+8, 14, 6);
  }
  function drawCloud(x,y,r){
    ctx.fillStyle='#fff';
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.arc(x+r*0.9,y- r*0.5,r*0.85,0,Math.PI*2);
    ctx.arc(x+r*1.8,y,r*1.1,0,Math.PI*2);
    ctx.arc(x+r*0.9,y+r*0.5,r*0.9,0,Math.PI*2);
    ctx.fill();
  }
  function drawPoo(o){
    const x=o.x, y=o.y, w=o.w, h=o.h;
    ctx.save(); ctx.translate(x, y);
    ctx.fillStyle='rgba(0,0,0,.15)'; ctx.beginPath(); ctx.ellipse(0, -4, w*0.4, 6, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='var(--poo)'; ctx.strokeStyle='var(--pooEdge)'; ctx.lineWidth=3*scale;
    roundBlob(-w*0.5, -h*0.3, w, h*0.34, 12);
    roundBlob(-w*0.36, -h*0.58, w*0.72, h*0.30, 10);
    roundBlob(-w*0.18, -h*0.86, w*0.36, h*0.26, 10);
    ctx.restore();
  }
  function roundBlob(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r); ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.fill(); ctx.stroke(); }

  function drawDog(){
    const x=dog.x, y=dog.y, w=dog.w, h=dog.h;
    ctx.save();
    ctx.translate(x,y);
    const tilt = Math.max(-0.16, Math.min(0.20, dog.vy/1600));
    ctx.rotate(tilt);
    ctx.drawImage(dogImg, -w*0.5, -h*0.5, w, h);
    ctx.restore();
  }
  function drawScore(){
    const pad = 14*scale;
    ctx.fillStyle='rgba(0,0,0,.25)';
    ctx.fillRect(pad, pad, 200*scale, 62*scale);
    ctx.fillStyle='#fff';
    ctx.font = `${24*scale}px system-ui, sans-serif`;
    ctx.fillText('Score: '+score, pad+10*scale, pad+26*scale);
    ctx.fillText('Best: '+best, pad+10*scale, pad+52*scale);
  }

  function gameOverState(){
    running=false; gameOver=true; paused=false;
    best = Math.max(best, score);
    localStorage.setItem('bru_best', best);
    scoreline.textContent = `Score: ${score} â€¢ Best: ${best}`;
    showOver();
  }

  // overlays
  function hideAll(){ intro.classList.remove('show'); pauseOv.classList.remove('show'); overOv.classList.remove('show'); }
  function showIntro(){ hideAll(); intro.classList.add('show'); }
  function showPause(){ hideAll(); pauseOv.classList.add('show'); }
  function showOver(){ hideAll(); overOv.classList.add('show'); }

  // input
  window.addEventListener('keydown', (e)=>{
    if(e.code==='Space'){ e.preventDefault(); pressJump(); }
    else if(e.key?.toLowerCase()==='p') { if(paused) resume(); else pause(); }
    else if(e.key?.toLowerCase()==='r') { reset(); }
    else if(e.key?.toLowerCase()==='s') { start(); }
  }, {passive:false});
  window.addEventListener('keyup', (e)=>{ if(e.code==='Space'){ e.preventDefault(); releaseJump(); }}, {passive:false});

  canvas.addEventListener('pointerdown', (e)=>{ e.preventDefault(); if(gameOver){ reset(); start(); } else pressJump(); }, {passive:false});
  canvas.addEventListener('pointerup', (e)=>{ e.preventDefault(); releaseJump(); }, {passive:false});
  canvas.addEventListener('pointercancel', ()=> releaseJump(), {passive:true});

  startBtn.addEventListener('click', ()=>{ if(gameOver){ reset(); start(); } else pressJump(); });
  pauseBtn.addEventListener('click', ()=>{ if(paused) resume(); else pause(); });

  bigStart.addEventListener('click', ()=>{ start(); });
  bigResume.addEventListener('click', ()=>{ resume(); });
  bigRestart.addEventListener('click', ()=>{ reset(); start(); });

  reset();
})();
} catch (e) {
  const errBox = document.getElementById('err');
  if (errBox) { errBox.textContent = 'Error: ' + (e && e.message ? e.message : e); errBox.classList.add('show'); }
  console.error(e);
}
</script>
</body>
</html>
