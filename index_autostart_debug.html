<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<title>Brus Gotta Poo!</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  :root {
    --bg1:#cde7ff; --bg2:#f7efe3; --text:#2b2b2b;
    --ground:#d2c3a4; --grass:#9dbc6f; --track:#b6a684;
    --poo:#7b4a21; --pooEdge:#5e3a18; --card:#263238ee;
  }
  * { box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  html,body { height:100%; margin:0; background:var(--bg2); color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  .wrap { position:fixed; inset:0; display:grid; grid-template-rows: 1fr auto; }
  canvas { width:100%; height:100%; display:block; touch-action: manipulation; }
  .hud { display:flex; gap:10px; align-items:center; justify-content:center; padding:8px env(safe-area-inset-right) calc(8px + env(safe-area-inset-bottom)) env(safe-area-inset-left); background: linear-gradient(180deg, #0000, #0001); }
  .btn { border:0; border-radius:12px; padding:10px 14px; background:#ffd54f; font-weight:700; color:#3a300e; }
  .btn:active { transform: translateY(1px) scale(.99); }
  .overlay {
    position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:12px;
    background:rgba(0,0,0,.5); color:#fff; text-align:center; padding:20px;
  }
  .card { background: var(--card); padding:20px 26px; border-radius:16px; max-width:min(560px, 86vw); box-shadow: 0 10px 30px #0007; }
  .title { font-size:28px; font-weight:900; margin-bottom:6px; }
  .subtitle { font-size:18px; opacity:.95; margin-bottom:10px; }
  .hidden { display:none; }
  .debug { position: fixed; top: 6px; right: 8px; background: rgba(0,0,0,.4); color:#fff; padding:6px 8px; border-radius:10px; font: 12px/1.2 system-ui, sans-serif; }
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="900" height="420" aria-label="Brus Gotta Poo! Endless Runner"></canvas>

  <!-- Intro Overlay -->
  <div id="intro" class="overlay">
    <div class="card">
      <div class="title">Brus Gotta Poo!</div>
      <div class="subtitle">Tap to Begin</div>
      <button id="startBig" class="btn">Start</button>
    </div>
  </div>

  <!-- Pause Overlay -->
  <div id="pauseOv" class="overlay hidden">
    <div class="card">
      <div class="title">Paused</div>
      <div class="subtitle">Tap or press P to resume.</div>
      <button id="resumeBig" class="btn">Resume</button>
    </div>
  </div>

  <!-- Game Over Overlay -->
  <div id="over" class="overlay hidden">
    <div class="card">
      <div class="title">Game Over ðŸ’©</div>
      <div id="scoreline" class="subtitle">Score: 0 â€¢ Best: 0</div>
      <button id="restartBig" class="btn">Restart</button>
    </div>
  </div>

  <div class="hud">
    <button id="startBtn" class="btn">Start / Jump (Tap/Space)</button>
    <button id="pauseBtn" class="btn" style="background:#b3e5fc;color:#0a2a3a">Pause (P)</button>
    <span class="subtitle" style="color:#000;opacity:.7;">Quick taps = small hops, hold to jump higher. Avoid the ðŸ’©</span>
  </div>

  <div id="debug" class="debug">state:init â€¢ t=0.00</div>
</div>
<script>
(()=>{
  // DOM
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const intro = document.getElementById('intro');
  const pauseOv = document.getElementById('pauseOv');
  const over = document.getElementById('over');
  const scoreline = document.getElementById('scoreline');
  const startBig = document.getElementById('startBig');
  const resumeBig = document.getElementById('resumeBig');
  const restartBig = document.getElementById('restartBig');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const debugEl = document.getElementById('debug');

  // Fit canvas
  let scale = 1;
  function fit(){
    const ratio = Math.min(window.devicePixelRatio || 1.5, 2);
    const cssW = window.innerWidth;
    const cssH = window.innerHeight - 64;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(cssW * ratio);
    canvas.height = Math.round(cssH * ratio);
    scale = ratio;
  }
  window.addEventListener('resize', fit, {passive:true});
  fit();

  // Game constants
  const GROUND_Y = ()=> canvas.height * 0.78;
  const GRAVITY = 2900;
  const JUMP_V0 = -760;
  const HOLD_ACCEL = -3200;
  const HOLD_MAX = 0.18;
  const SCROLL_BASE = 520;
  const SPEED_TIME_INC = 44;
  const SPEED_SCORE_INC = 14;
  const DOG_X = ()=>canvas.width*0.2;

  // State
  let running=false, paused=false, last=0, t=0, score=0, best=parseInt(localStorage.getItem('bru_best')||'0',10);
  let dog, obstacles, clouds, hills1, hills2, gameOver=false, jumpHeld=false;
  let rafId = 0;

  // Draw functions
  function drawDog(x,y,w,h,vy,legT,onGround){
    ctx.save();
    ctx.translate(x,y);
    const tilt = Math.max(-0.16, Math.min(0.20, vy/1600));
    ctx.rotate(tilt);
    ctx.lineWidth = 3*scale;
    ctx.fillStyle = '#d79a4a'; ctx.strokeStyle = '#8b5e34';
    roundRect(-w*0.34, -h*0.26, w*0.68, h*0.52, 16);
    ctx.fillStyle = '#f0c98b'; roundRect(-w*0.18, -h*0.06, w*0.32, h*0.22, 10);
    ctx.fillStyle = '#d79a4a';
    roundRect(w*0.22, -h*0.3, w*0.34, h*0.36, 12);
    roundRect(w*0.28, -h*0.12, w*0.26, h*0.18, 10);
    ctx.fillStyle='#2b2b2b'; ctx.beginPath(); ctx.arc(w*0.50, -h*0.02, 4*scale, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle='#8b5e34'; ctx.fillStyle='#d79a4a';
    ctx.beginPath(); ctx.moveTo(w*0.26, -h*0.24); ctx.quadraticCurveTo(w*0.16, -h*0.06, w*0.28, 0); ctx.quadraticCurveTo(w*0.30, -h*0.08, w*0.26, -h*0.24); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(w*0.36, -h*0.12, 3.2*scale, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle='#8b5e34'; ctx.beginPath(); ctx.moveTo(-w*0.34, -h*0.06); ctx.quadraticCurveTo(-w*0.52, -h*0.22 + Math.sin(legT*4)*5*scale, -w*0.66, -h*0.02); ctx.stroke();
    const phase = Math.sin(legT)*0.9*(onGround?1:0.6);
    drawLeg(w*0.10, h*0.22, 14*scale, 18*scale, phase);
    drawLeg(-w*0.12, h*0.22, 14*scale, 18*scale, -phase);
    ctx.restore();
  }
  function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r); ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.fill(); ctx.stroke(); }
  function drawPoo(x,y,w,h){
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='rgba(0,0,0,.15)'; ctx.beginPath(); ctx.ellipse(0, -4, w*0.4, 6, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='var(--poo)'; ctx.strokeStyle='var(--pooEdge)'; ctx.lineWidth=3*scale;
    blob(-w*0.5, -h*0.3, w, h*0.34, 12);
    blob(-w*0.36, -h*0.58, w*0.72, h*0.30, 10);
    blob(-w*0.18, -h*0.86, w*0.36, h*0.26, 10);
    ctx.restore();
  }
  function blob(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y, x+w,y+h, r); ctx.arcTo(x+w,y+h, x,y+h, r); ctx.arcTo(x,y+h, x,y, r); ctx.arcTo(x,y, x+w,y, r); ctx.fill(); ctx.stroke(); }
  function aabb(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

  // Init/reset
  function reset(){
    running=false; paused=false; gameOver=false; t=0; score=0; jumpHeld=false;
    dog = { x:DOG_X(), y:GROUND_Y()-64, vy:0, w:132, h:88, onGround:true, legT:0, jumpHoldT:0 };
    obstacles=[];
    clouds = new Array(6).fill(0).map((_,i)=>({x: i*320 + Math.random()*220, y: 60+Math.random()*130, s: 18+Math.random()*24 }));
    hills1 = new Array(5).fill(0).map((_,i)=>({x:i*400, h: 90+Math.random()*40}));
    hills2 = new Array(5).fill(0).map((_,i)=>({x:i*500, h: 140+Math.random()*60}));
    spawnObstacle(canvas.width + 900 + Math.random()*400);
    show(intro);
    render(); // draw static intro
    debug('state:intro â€¢ t=0.00');
  }

  function start(){
    running=true; paused=false; gameOver=false;
    hideAll();
    last = performance.now();
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);
    debug('state:running â€¢ t=' + t.toFixed(2));
  }
  function pause(){
    if(!running || gameOver) return;
    paused=true;
    show(pauseOv);
    debug('state:paused â€¢ t=' + t.toFixed(2));
  }
  function resume(){
    if(!running || gameOver) return;
    paused=false;
    hideAll();
    last = performance.now();
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);
    debug('state:running â€¢ t=' + t.toFixed(2));
  }

  // Spawn
  function spawnObstacle(x0){
    const size = 34 + Math.random()*26;
    obstacles.push({ x:x0, y:GROUND_Y(), w:size*1.3, h:size, passed:false });
    if(Math.random()<0.28){ const gap= 170+Math.random()*70;
      obstacles.push({ x:x0+gap, y:GROUND_Y(), w:size*1.15, h:size*0.95, passed:false });
    }
  }

  // Loop
  function loop(now){
    if(!running || paused) return;
    const dt = Math.min((now-last)/1000, 1/30);
    last = now;
    update(dt);
    render();
    rafId = requestAnimationFrame(loop);
  }

  function update(dt){
    t += dt;
    const speed = SCROLL_BASE + t*SPEED_TIME_INC + score*SPEED_SCORE_INC;

    // physics
    dog.vy += GRAVITY * dt;
    if(jumpHeld && !dog.onGround && dog.jumpHoldT < HOLD_MAX && dog.vy < 0){ dog.vy += HOLD_ACCEL*dt; dog.jumpHoldT+=dt; }
    dog.y += dog.vy * dt;
    dog.legT += dt * (dog.onGround ? (7 + speed*0.0032) : 4.2);
    if(dog.y + dog.h/2 >= GROUND_Y()){ dog.y=GROUND_Y()-dog.h/2; dog.vy=0; dog.onGround=true; dog.jumpHoldT=0; }

    // parallax
    for (let c of clouds){ c.x -= speed*0.12*dt; if(c.x<-160){ c.x+=canvas.width+360; c.y=40+Math.random()*140; } }
    for (let h of hills2){ h.x -= speed*0.18*dt; if(h.x<-520) h.x+=canvas.width+520; }
    for (let h of hills1){ h.x -= speed*0.24*dt; if(h.x<-420) h.x+=canvas.width+420; }

    // obstacles
    if(obstacles.length===0 || obstacles[obstacles.length-1].x < canvas.width - 560){ spawnObstacle(canvas.width + 280 + Math.random()*280); }
    for (let o of obstacles){
      o.x -= speed * dt;
      if(!o.passed && o.x + o.w/2 < dog.x - dog.w/2){ o.passed=true; score++; }
    }
    if(obstacles.length && obstacles[0].x + obstacles[0].w < -60) obstacles.shift();

    // collisions
    const dogBox = {x:dog.x-dog.w*0.30, y:dog.y-dog.h*0.44, w:dog.w*0.60, h:dog.h*0.88};
    for (let o of obstacles){
      const ob = {x:o.x-o.w*0.5, y:o.y-o.h, w:o.w, h:o.h};
      if(aabb(dogBox, ob)) return onGameOver();
    }
  }

  // Render
  function render(){
    // sky
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,'#cde7ff'); g.addColorStop(1,'#f7efe3');
    ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
    // clouds
    for (let c of clouds) drawCloud(c.x, c.y, c.s);
    // hills
    drawHills(hills2, '#c8d4e7'); drawHills(hills1, '#b9d2e8');
    // ground
    drawGround();
    // obstacles
    for (let o of obstacles) drawPoo(o.x, o.y, o.w, o.h);
    // dog
    drawDog(dog.x, dog.y, dog.w, dog.h, dog.vy, dog.legT, dog.onGround);
    // score
    drawScore();
    debug('state:' + (paused?'paused':(running?'running':(gameOver?'over':'intro'))) + ' â€¢ t=' + t.toFixed(2));
  }

  function drawHills(list, color){
    ctx.fillStyle=color;
    const y=GROUND_Y();
    for (let h of list){
      ctx.beginPath();
      ctx.moveTo(h.x-300, y);
      ctx.quadraticCurveTo(h.x, y-h.h, h.x+300, y);
      ctx.closePath(); ctx.fill();
    }
  }
  function drawGround(){
    const y=GROUND_Y();
    ctx.fillStyle='var(--ground)'; ctx.fillRect(0, y, canvas.width, canvas.height-y);
    ctx.fillStyle='var(--grass)'; ctx.fillRect(0, y-6, canvas.width, 6);
    ctx.fillStyle='var(--track)';
    const step=28, off=(t*140)%step;
    for(let x=-step;x<canvas.width+step;x+=step) ctx.fillRect(Math.floor(x-off), y+8, 14, 6);
  }
  function drawCloud(x,y,r){
    ctx.fillStyle='#fff';
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.arc(x+r*0.9,y- r*0.5,r*0.85,0,Math.PI*2);
    ctx.arc(x+r*1.8,y,r*1.1,0,Math.PI*2);
    ctx.arc(x+r*0.9,y+r*0.5,r*0.9,0,Math.PI*2);
    ctx.fill();
  }
  function drawScore(){
    const pad = 14*scale;
    ctx.fillStyle='rgba(0,0,0,.25)';
    ctx.fillRect(pad, pad, 200*scale, 62*scale);
    ctx.fillStyle='#fff';
    ctx.font = `${24*scale}px system-ui, sans-serif`;
    ctx.fillText('Score: '+score, pad+10*scale, pad+26*scale);
    ctx.fillText('Best: '+best, pad+10*scale, pad+52*scale);
  }

  function onGameOver(){
    running=false; gameOver=true; paused=false;
    best = Math.max(best, score);
    localStorage.setItem('bru_best', best);
    scoreline.textContent = 'Score: ' + score + ' â€¢ Best: ' + best;
    show(over);
    debug('state:over â€¢ t=' + t.toFixed(2));
  }

  // Overlay helpers
  function hideAll(){ intro.classList.add('hidden'); pauseOv.classList.add('hidden'); over.classList.add('hidden'); }
  function show(el){ hideAll(); el.classList.remove('hidden'); }

  // Input
  function press(){ if(!running){ start(); return; } if(paused||gameOver) return; if(dog.onGround){ dog.vy=JUMP_V0; dog.onGround=false; dog.jumpHoldT=0; jumpHeld=true; } }
  function release(){ jumpHeld=false; }

  // Auto-start on first tap/click anywhere on the page for safety
  let booted = false;
  function firstStart(){ if(!booted){ booted = true; start(); document.removeEventListener('pointerdown', firstStart, {passive:false}); } }
  document.addEventListener('pointerdown', firstStart, {passive:false});

  window.addEventListener('keydown', (e)=>{
    if(e.code==='Space'){ e.preventDefault(); press(); }
    else if(e.key?.toLowerCase()==='p'){ if(paused) { resume(); } else { pause(); } }
    else if(e.key?.toLowerCase()==='r'){ reset(); }
    else if(e.key?.toLowerCase()==='s'){ start(); }
  }, {passive:false});
  window.addEventListener('keyup', (e)=>{ if(e.code==='Space'){ e.preventDefault(); release(); } }, {passive:false});
  canvas.addEventListener('pointerdown', (e)=>{ e.preventDefault(); if(gameOver){ reset(); start(); } else press(); }, {passive:false});
  canvas.addEventListener('pointerup', (e)=>{ e.preventDefault(); release(); }, {passive:false});
  canvas.addEventListener('pointercancel', ()=> release(), {passive:true});
  startBtn.addEventListener('click', ()=>{ if(gameOver){ reset(); start(); } else press(); });
  pauseBtn.addEventListener('click', ()=>{ if(paused){ resume(); } else { pause(); } });
  startBig.addEventListener('click', ()=> start());
  resumeBig.addEventListener('click', ()=> resume());
  restartBig.addEventListener('click', ()=>{ reset(); start(); });

  function debug(msg){ debugEl.textContent = msg; }

  // Boot
  reset();
})();
</script>
</body>
</html>
